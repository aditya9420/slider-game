function init(){
  puzzle.style.setProperty('--size', size);
  puzzle.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
  puzzle.style.width = "500px";
  puzzle.style.height = "500px";
  puzzle.innerHTML = '';
  tiles = [];

  let count = 0;
  for(let row=0; row<size; row++){
    for(let col=0; col<size; col++){
      count++;
      const index = row*size+col;
      if(count === size*size){
        emptyIndex = index;
        tiles.push(null);
        continue;
      }
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.style.backgroundImage = `url(${imgUrl})`;
      tile.style.backgroundSize = `${size*100}% ${size*100}%`;
      tile.style.backgroundPosition = `${(col/(size-1))*100}% ${(row/(size-1))*100}%`;
      tile.style.aspectRatio = '1/1';
      tile.dataset.correct = index;

      // ðŸŸ¢ click looks up current index dynamically
      tile.addEventListener('click', () => {
        const currentIndex = tiles.indexOf(tile);
        move(currentIndex);
      });

      puzzle.appendChild(tile);
      tiles.push(tile);
    }
  }
  preview.src = imgUrl;
}

function move(index, isShuffling=false){
  const row = Math.floor(index/size);
  const col = index % size;
  const emptyRow = Math.floor(emptyIndex/size);
  const emptyCol = emptyIndex % size;

  if((row===emptyRow && Math.abs(col-emptyCol)===1) || (col===emptyCol && Math.abs(row-emptyRow)===1)){
    [tiles[index], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[index]];
    updatePositions();
    emptyIndex = index;

    if(!isShuffling){
      moveCount++;
      movesEl.textContent = moveCount;
      startTimer();
      checkWin();
    }
  }
}
